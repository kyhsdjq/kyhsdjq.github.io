---
title: "ZGC"
date: 2025-10-18 23:12:00 +0800
categories: [Note, Java, Garbage Collector]
tags: [computer science]     # TAG names should always be lowercase
author: kyhsdjq
description: Introduction to ZGC, a Java garbage collector.
media_subpath: /imgs/note
math: true
# mermaid: true
---

## 引入

在 ZGC 出现之前，Java 主流的 GC 是 G1，来看看它们之间的区别：

### 对象存储

ZGC 刚出现的时候（于 JDK 15 进入生产环境），和 G1 使用相同的**分区存储**。它们将对象按大小粗略地放在 grid 中，每次回收时只针对需回收对象较多的 grid 进行回收。

在 JDK 21 中，Java 为 ZGC 引入**分代存储**，进一步提升 ZGC 的性能。

### 回收流程

ZGC 和 G1 都采用标记-整理来回收垃圾。

|G1|ZGC|
|:---|:---|
|预标记|预标记|
|并发标记|并发标记|
|再标记|再标记|
|清理|预转移|
|复制|并发转移|

可以看到区别只在最后两个步骤。G1 选择清理后 STW (Stop The World) 来复制对象，而 ZGC 实现了**并发转移**，这是它比 G1 回收快的主要原因。

## 并发转移

### 并发安全实现

> 其他有关 ZGC 的文章基本忽略了如何安全实现并发，只关注它如何优化并发效率。但我认为这才是 ZGC 的核心特点，应该放在开头讲讲。
{: .prompt-tip }

要实现安全的并发，加锁是自然的做法。我们可以把 STW 的过程看作给整个内存加一把大锁，要提高效率，只需将这把大锁拆分为粒度更细的锁，也就是为每个区域加一把锁。

ZGC 中每个区域都有自己的**转移表**，于是该区域的锁存放在转移表中。以下是在转移中确保并发安全的两个手段，它们的思路都类似**乐观锁**：
- 引用计数：确认区域是否正被使用
- 写入时确认：复制对象后，向转移表中写入时确认为空，否则回滚

#### 引用计数

ZGC 通过引用计数来确认区域是否正被使用。

来看看转移过程的代码（[ jdk17 中的 ZGC 实现](https://github.com/openjdk/jdk17/blob/master/src/hotspot/share/gc/z/zRelocate.cpp#L87)）：

```c++
uintptr_t ZRelocate::relocate_object(ZForwarding* forwarding, uintptr_t from_addr) const {
  ZForwardingCursor cursor;

  // Lookup forwarding
  uintptr_t to_addr = forwarding_find(forwarding, from_addr, &cursor);
  if (to_addr != 0) {
    // Already relocated
    return to_addr;
  }

  // Relocate object
  if (forwarding->retain_page()) {
    to_addr = relocate_object_inner(forwarding, from_addr, &cursor);
    forwarding->release_page();

    if (to_addr != 0) {
      // Success
      return to_addr;
    }

    // Failed to relocate object. Wait for a worker thread to complete
    // relocation of this page, and then forward the object. If the GC
    // aborts the relocation phase before the page has been relocated,
    // then wait return false and we just forward the object in-place.
    if (!forwarding->wait_page_released()) {
      // Forward object in-place
      return forwarding_insert(forwarding, from_addr, from_addr, &cursor);
    }
  }

  // Forward object
  return forward_object(forwarding, from_addr);
}
```

可以看到：其中通过 [retain_page](https://github.com/openjdk/jdk17/blob/master/src/hotspot/share/gc/z/zForwarding.cpp#L50) 尝试使用该区域：

```c++
bool ZForwarding::retain_page() {
  for (;;) {
    const int32_t ref_count = Atomic::load_acquire(&_ref_count);

    if (ref_count == 0) {
      // Released
      return false;
    }

    if (ref_count < 0) {
      // Claimed
      const bool success = wait_page_released();
      assert(success, "Should always succeed");
      return false;
    }

    if (Atomic::cmpxchg(&_ref_count, ref_count, ref_count + 1) == ref_count) {
      // Retained
      return true;
    }
  }
}
```

这个函数通过与 _ref_count 的原子交互来获取和更新状态，也就是**乐观锁**的思路。

分析一下 _ref_count 的含义：

|值|含义|
|:---|:---|
|$$>0$$|有 N 个线程正在使用页面	|
|$$=0$$|页面已释放，无线程使用|
|$$<0$$|页面被声明/保留，准备进行操作|

相关的函数还有 [release_page](https://github.com/openjdk/jdk17/blob/master/src/hotspot/share/gc/z/zForwarding.cpp#L96) ，它尝试让 _ref_count 的绝对值减少，表示使用/声明页面的线程数减少；并且当 _ref_count 为 0 的时候广播信号量。

```c++
void ZForwarding::release_page() {
  for (;;) {
    const int32_t ref_count = Atomic::load(&_ref_count);
    assert(ref_count != 0, "Invalid state");

    if (ref_count > 0) {
      // Decrement reference count
      if (Atomic::cmpxchg(&_ref_count, ref_count, ref_count - 1) != ref_count) {
        continue;
      }

      // If the previous reference count was 1, then we just decremented
      // it to 0 and we should signal that the page is now released.
      if (ref_count == 1) {
        // Notify released
        ZLocker<ZConditionLock> locker(&_ref_lock);
        _ref_lock.notify_all();
      }
    } else {
      // Increment reference count
      if (Atomic::cmpxchg(&_ref_count, ref_count, ref_count + 1) != ref_count) {
        continue;
      }

      // If the previous reference count was -2 or -1, then we just incremented it
      // to -1 or 0, and we should signal the that page is now claimed or released.
      if (ref_count == -2 || ref_count == -1) {
        // Notify claimed or released
        ZLocker<ZConditionLock> locker(&_ref_lock);
        _ref_lock.notify_all();
      }
    }

    return;
  }
}
```

此外，通过 [wait_page_released](https://github.com/openjdk/jdk17/blob/master/src/hotspot/share/gc/z/zForwarding.cpp#L133) 等待页面空闲（未被任何线程使用/声明）：

```c++
bool ZForwarding::wait_page_released() const {
  if (Atomic::load_acquire(&_ref_count) != 0) {
    ZStatTimer timer(ZCriticalPhaseRelocationStall);
    ZLocker<ZConditionLock> locker(&_ref_lock);
    while (Atomic::load_acquire(&_ref_count) != 0) {
      if (_ref_abort) {
        return false;
      }

      _ref_lock.wait();
    }
  }

  return true;
}
```

#### 写入时确认

之前可以看到，relocate_object 内部调用 [relocate_object_inner](https://github.com/openjdk/jdk17/blob/master/src/hotspot/share/gc/z/zRelocate.cpp#L63) 来实现对象转移，看看它的源码：

```c++
static uintptr_t relocate_object_inner(ZForwarding* forwarding, uintptr_t from_addr, ZForwardingCursor* cursor) {
  assert(ZHeap::heap()->is_object_live(from_addr), "Should be live");

  // Allocate object
  const size_t size = ZUtils::object_size(from_addr);
  const uintptr_t to_addr = ZHeap::heap()->alloc_object_for_relocation(size);
  if (to_addr == 0) {
    // Allocation failed
    return 0;
  }

  // Copy object
  ZUtils::object_copy_disjoint(from_addr, to_addr, size);

  // Insert forwarding
  const uintptr_t to_addr_final = forwarding_insert(forwarding, from_addr, to_addr, cursor);
  if (to_addr_final != to_addr) {
    // Already relocated, try undo allocation
    ZHeap::heap()->undo_alloc_object_for_relocation(to_addr, size);
  }

  return to_addr_final;
}
```

它总是乐观地先复制对象，然后通过 forwarding_insert 尝试将新地址插入转移表，如果发现别的线程在之前插入过了，再进行回滚。

接下来看看 [forwarding_insert](https://github.com/openjdk/jdk17/blob/master/src/hotspot/share/gc/z/zRelocate.cpp#L56) 中的 [insert](https://github.com/openjdk/jdk17/blob/master/src/hotspot/share/gc/z/zForwarding.inline.hpp#L135) 如何发现这个地址已经被插入的

```c++
static uintptr_t forwarding_insert(ZForwarding* forwarding, uintptr_t from_addr, uintptr_t to_addr, ZForwardingCursor* cursor) {
  const uintptr_t from_index = forwarding_index(forwarding, from_addr);
  const uintptr_t to_offset = ZAddress::offset(to_addr);
  const uintptr_t to_offset_final = forwarding->insert(from_index, to_offset, cursor);
  return ZAddress::good(to_offset_final);
}

inline uintptr_t ZForwarding::insert(uintptr_t from_index, uintptr_t to_offset, ZForwardingCursor* cursor) {
  const ZForwardingEntry new_entry(from_index, to_offset);
  const ZForwardingEntry old_entry; // Empty

  for (;;) {
    const ZForwardingEntry prev_entry = Atomic::cmpxchg(entries() + *cursor, old_entry, new_entry);
    if (!prev_entry.populated()) {
      // Success
      return to_offset;
    }

    // Find next empty or matching entry
    ZForwardingEntry entry = at(cursor);
    while (entry.populated()) {
      if (entry.from_index() == from_index) {
        // Match found, return already inserted address
        return entry.to_offset();
      }

      entry = next(cursor);
    }
  }
}
```

看来同样是使用 CAS，观察转移表中的表项是否为空，如果不为空尝试找到已有的转移后的地址。

### 读屏障

我们已经看到 ZGC 如何通过转移表来保障并发安全，不过，显而易见的，转移表的主要用途是记录对象当前所在的位置。

当 jvm 在转移过程中想要访问一个对象时，“有时”需要借助转移表获取其当前位置，这个行为通过**读屏障**来实现。（此外，**标记**也是通过读屏障实现的。）

### 染色指针

不过，如果每次 jvm 要访问对象时，都去查询转移表来获取其转移后位置（或是为NULL，代表未转移），肯定会导致访问效率严重下降。

我们需要一种方式快速判断已有的对象地址是否是其当前的位置，于是**染色指针**应运而生。

简单而言，染色指针将地址的前若干位作为标识，表示该地址所处的空间。如果这个地址空间和当前 jvm 期望的空间不符，那么再去查询转移表来得到当前结果。

> 标记-整理 GC 策略中的“整理”指的是在物理地址上整理申请的空间，减少碎片并且缓存友好；而染色指针的颜色染在虚拟地址上，所以彼此不影响。
{: .prompt-info }

以下是一段加入染色指针后的读屏障**伪代码**：

```c++
uintptr_t read_barrier(uintptr_t &obj_addr) {
    if (is_current_space(obj_addr)) {
        return obj_addr;
    } 
    else {
        uintptr_t forwarding_table_addr = forwarding_table_lookup(obj_addr);
        if (is_current_space(forwarding_table_addr)) {
            obj_addr = forwarding_table_addr; // 指针自愈
            return forwarding_table_addr;
        } 
        else {
            return relocate_object(obj_addr); // 协助转移对象
        }
    }
}
```

### 并发转移总结

以上已经讨论了 ZGC 对并发转移的实现和优化，让我们总结下并发转移期间所有可能发生的情况：

|情况|观察|行为|
|:---|:---|:---|
|访问到未转移的对象|染色指针不符合，查询转移表，发现未转移|当前线程协助该对象转移|
|通过旧地址访问到转移后的对象|染色指针不符合，查询转移表，发现转移完成|根据转移表中的地址访问<br>指针自愈|
|通过新地址访问到转移后的对象|染色指针符合|直接访问|